/*

      V
      |
    Zve64d
      |
    Zve64f
   /      \
Zve64x   Zve32f
   \      /
    Zve32x

Sections:
  misa.v bit
  eew in [8,16,32,64]
  vlen >= 128
Configuration-Setting Instructions
Vector Load and Store Instructions
  xlen=32 -> eew != 64
  xlen=64:
Vector Integer Arithmetic Instructions
  zve64* + eew=64 -> NO vmulh.vv, vmulh.vx, vmulhu.vv, vmulhu.vx, vmulhsu.vv, vmulhsu.vx (integer multiply variants that return the high word of the product)
Vector Fixed-point Arithmetic Instructions
  zve64* + eew=64 -> NO vsmul.vv/vsmul.vx
Vector Single-Width Integer Reduction Instructions
Vector Widening Integer Reduction Instructions
Vector Mask Instructions
Vector Permutation Instructions
  zve32x,zve64x -> NO floating-point scalar move instructions
Vector Floating-Point Instructions
  eew=32
  v,zve64d -> eew=64
  v,zve64d -> +widening instructions/conversions(32->64)
Vector Single-Width Floating-Point reduction Instructions
  eew=32
  v,zve64d -> eew=64
  v,zve64d -> +widening reductions(32->64)
*/
/*
*/

import "RV32I.core_desc"
import "RISCVBase.core_desc"

InstructionSet RV32V extends RVV {
}

/*InstructionSet RV64V extends RV32V{}*/


InstructionSet RVV extends RVZve64d {
// What missing?
        // -- Configuration-Setting Instructions
        // -- Vector Load and Store Instructions
        // -- Vector Integer Arithmetic Instructions
        // -- Vector Fixed-point Arithmetic Instructions
        // -- Vector Single-Width Integer Reduction Instructions
        // -- Vector Widening Integer Reduction Instructions
        // -- Vector Mask Instructions
        // -- Vector Permutation Instructions
        // -- Vector Floating-Point Instructions
        // -- Vector Single-Width Floating-Point Reduction Instructions
        // -- Vector Widening Floating-Point Reduction Instructions
        // -- 2 Sort
}

InstructionSet RVZve64d extends RVZve64f {
// + double precision
    // functions {
    //     bool validate_rvv() {
    //         unsigned<XLEN> _eew = vcfg_concatEEW(mew, width);
    //         return extension_enabled("V") && extension_enabled("F") && (_eew == 32 || _eew == 64);
    //     }
    // }
        // -- Configuration-Setting Instructions
        // -- Vector Load and Store Instructions
        // -- Vector Integer Arithmetic Instructions
        // -- Vector Fixed-point Arithmetic Instructions
        // -- Vector Single-Width Integer Reduction Instructions
        // -- Vector Widening Integer Reduction Instructions
        // -- Vector Mask Instructions
        // -- Vector Permutation Instructions
        // -- Vector Floating-Point Instructions
        //    v,zve64d -> eew=64
        //    v,zve64d -> +widening instructions/conversions(32->64)
        // -- Vector Single-Width Floating-Point Reduction Instructions
        //    v,zve64d -> eew=64
        // -- Vector Widening Floating-Point Reduction Instructions
        //    v,zve64d only
        // -- 2 Sort
}

InstructionSet RVZve64f extends RVZve32f, RVZve64x {
// Ensure?
    // functions {
    //     bool validate_rvv() {
    //         unsigned<XLEN> _eew = vcfg_concatEEW(mew, width);
    //         return extension_enabled("V") && extension_enabled("F") && (_eew == 32);
    //     }
    // }
        // -- Configuration-Setting Instructions
        // -- Vector Load and Store Instructions
        // -- Vector Integer Arithmetic Instructions
        // -- Vector Fixed-point Arithmetic Instructions
        // -- Vector Single-Width Integer Reduction Instructions
        // -- Vector Widening Integer Reduction Instructions
        // -- Vector Mask Instructions
        // -- Vector Permutation Instructions
        // -- Vector Floating-Point Instructions
        // -- Vector Single-Width Floating-Point Reduction Instructions
        // -- Vector Widening Floating-Point Reduction Instructions
        // -- 2 Sort
}

InstructionSet RVZve32f extends RVZve32x {
// + single precision
    // functions {
    //     bool validate_rvv() {
    //         unsigned<XLEN> _eew = vcfg_concatEEW(mew, width);
    //         return extension_enabled("V") && extension_enabled("F") && _eew == 32;
    //     }
    // }
    // instructions [[enable=validate_rvv()]]{
    instructions {
        // -- Configuration-Setting Instructions
        // -- Vector Load and Store Instructions
        // -- Vector Integer Arithmetic Instructions
        // -- Vector Fixed-point Arithmetic Instructions
        // -- Vector Single-Width Integer Reduction Instructions
        // -- Vector Widening Integer Reduction Instructions
        // -- Vector Mask Instructions
        // -- Vector Permutation Instructions
        // -- Vector Floating-Point Instructions
        // vfadd.vf?
        // vfadd.vv?
        // vfclass.v?
        // vfcvt.f.x.v?
        // vfcvt.f.xu.v?
        // vfcvt.rtz.x.f.v?
        // vfcvt.rtz.xu.f.v?
        // vfcvt.x.f.v?
        // vfcvt.xu.f.v?
        // vfdiv.vf?
        // vfdiv.vv?
        // vfmadd.vf?
        // vfmadd.vv?
        // vfmax.vf?
        // vfmax.vv?
        // vfmerge.vfm?
        // vfmin.vf?
        // vfmin.vv?
        // vfmsac.vf?
        // vfmsac.vv?
        // vfmsub.vf?
        // vfmsub.vv?
        // vfmul.vf?
        // vfmul.vv?
        // vfncvt.f.f.w?
        // vfncvt.f.x.w?
        // vfncvt.f.xu.w?
        // vfncvt.rod.f.f.w?
        // vfncvt.rtz.x.f.w?
        // vfncvt.rtz.xu.f.w?
        // vfncvt.x.f.w?
        // vfncvt.xu.f.w?
        // vfnmacc.vf?
        // vfnmacc.vv?
        // vfnmadd.vf?
        // vfnmadd.vv?
        // vfnmsac.vf?
        // vfnmsac.vv?
        // vfnmsub.vf?
        // vfnmsub.vv?
        // vfrdiv.vf?
        // vfrec7.v?
        // vfrsub.vf?
        // vfsgnj.vf?
        // vfsgnj.vv?
        // vfsgnjn.vf?
        // vfsgnjn.vv?
        // vfsgnjx.vf?
        // vfsgnjx.vv?
        // vfsqrt7.v?
        // vfsrqt.v?
        // vfsub.vf?
        // vfsub.vv?
        // vfwadd.vf?
        // vfwadd.wv?
        // vfwadd.wf?
        // vfwadd.vv?
        // vfwcvt.f.f.v?
        // vfwcvt.f.x.v?
        // vfwcvt.f.xu.v?
        // vfwcvt.rtz.x.f.v?
        // vfwcvt.rtz.xu.f.v?
        // vfwcvt.x.f.v?
        // vfwcvt.xu.f.v?
        // vfwmacc.vf?
        // vfwmacc.vv?
        // vfwmsac.vf?
        // vfwmsac.vv?
        // vfwmul.vf?
        // vfwmul.vv?
        // vfwnmacc.vf?
        // vfwnmacc.vv?
        // -- Vector Single-Width Floating-Point Reduction Instructions
        // vfredmax.vs?
        // vfredmin.vs?
        // vfredosum.vs?
        // vfredusum.vs?
        // -- Vector Widening Floating-Point Reduction Instructions
        // vfwredosum.vs?
        // vfwredusum.vs?
        // -- 2 Sort
        VFMERGE {
          encoding: 6'b010111 :: 1'b0 :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs1)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VFMV_V_F {
          encoding: 6'b010111 :: 1'b1 :: 5'b00000 :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs1)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
    }
}

InstructionSet RVZve64x extends RVZve32x {
// +eew=64
    instructions {
        // -- Configuration-Setting Instructions
        // -- Vector Load and Store Instructions
        // -- Vector Integer Arithmetic Instructions
        // -- Vector Fixed-point Arithmetic Instructions
        // -- Vector Single-Width Integer Reduction Instructions
        // -- Vector Widening Integer Reduction Instructions
        // -- Vector Mask Instructions
        // -- Vector Permutation Instructions
        // -- 2 Sort
        // Unitstride, 64 bit element
        VLE64_U {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _eew = vcfg_concatEEW(1'b0, 3'b111);
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = etiss_vload_encoded_unitstride(V, _vtype, vm, _eew, vd, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); // V, MEM[-1],
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VLE64_S {
            encoding: 3'b000 :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLE64FF_U {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b10000 :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLSEGE64 {
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        // Unitstride, 64 bit element
        VSE64_U {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _eew = vcfg_concatEEW(1'b0, 3'b111);
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = etiss_vstore_encoded_unitstride(V, _vtype, vm, _eew, vs3, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); //V, MEM[-1],
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VSE64_S {
            encoding: 3'b000 :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
    }
}

InstructionSet RVZve32x extends RVVBase {

// No float
// No eew=64
    functions {
        extern unsigned<8> etiss_vload_encoded_unitstride(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<16> pEEW, unsigned<8> pVd, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<64> pMSTART) [[etiss_needs_arch]];
        extern unsigned<8> etiss_vstore_encoded_unitstride(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<16> pEEW, unsigned<8> pVd, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<64> pMSTART) [[etiss_needs_arch]];
        extern unsigned<8> vadd_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vadd_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vadd_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vsub_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vsub_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vwaddu_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vwaddu_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vwadd_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vwadd_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vwsubu_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vwsubu_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vwsub_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vwsub_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vwaddu_w_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vwaddu_w_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vwadd_w_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vwadd_w_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vwsubu_w_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vwsubu_w_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vwsub_w_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vwsub_w_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vand_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vand_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vand_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vor_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vor_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vor_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vxor_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vxor_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vxor_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vsll_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vsll_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vsll_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vsrl_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vsrl_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vsrl_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vsra_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vsra_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vsra_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmseq_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmseq_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmseq_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmsne_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsne_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsne_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmsltu_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsltu_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmslt_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmslt_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmsleu_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsleu_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsleu_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmsle_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsle_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsle_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmsgtu_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsgtu_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmsgt_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsgt_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmv_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVd, unsigned<8> pVs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmv_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVd, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmv_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVd, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmv_xs(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pRd, unsigned<8> pVs2, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmv_sx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVd, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vslideup_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vslideup_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vslidedown_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vslidedown_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vslide1up_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vslide1down_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
    }
    instructions {
        // -- Configuration-Setting Instructions
        VSETVLI {
            encoding: 1'b0 :: zimm[10:0] :: rs1[4:0] :: 3'b111 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(rd)}, {name(rs1)}, {zimm}";
            behavior: {
                if(!(CSR[CSR_MSTATUS] & MSTATUS_VS)){
                    raise(0, 2);  // vpu not enabled
                }

                unsigned<3> sew[3]  = vtype_extractSEW(zimm);
                unsigned<3> lmul[3] = vtype_extractLMUL(zimm);
                unsigned<1> vta[1]  = vtype_extractTA(zimm);
                unsigned<1> vma[1]  = vtype_extractMA(zimm);

                unsigned<32> _vlmax = 0;
                unsigned<32> _illmask = 0;

                unsigned<32> vlen = CSR[VLENB_ADDR]*8;

                if (lmul & 4){
                    _illmask = (1 << (XLEN-1));
                    if(lmul == 6){
                        _vlmax = vlen / (0x8 << sew) / 4;
                    }else if(lmul == 7){
                        _vlmax = vlen / (0x8 << sew) / 2;
                    }else{
                        _vlmax = vlen / (0x8 << sew) / 8;
                    }
                }else {
                    _illmask = (0 << (XLEN-1));
                    if(lmul == 0){
                        _vlmax = vlen / (0x8 << sew);
                    }else if(lmul == 1){
                        _vlmax = vlen / (0x8 << sew) *2;
                    }else if(lmul == 2){
                        _vlmax = vlen / (0x8 << sew) *4;
                    }else if(lmul == 3){
                        _vlmax = vlen / (0x8 << sew) *8;
                    }
                }
                unsigned<32> _avl = 0;
                if (rs1 != 0){
                    _avl = X[rs1];
                }else if(rd != 0){
                    _avl = ~0;
                }else{
                    _avl = CSR[VL_ADDR];
                }

                unsigned<32> _vl = 0;

                if(_avl <= _vlmax){
                   _vl = _avl;
                }else if(_avl >= (2*_vlmax)){
                   _vl = _vlmax;
                }else{
                   _vl = (_avl % 0x2) ?  _avl/2 + 1 : _avl / 2; // ceil (AVL/2)
                }

                CSR[VL_ADDR] = _vl;
                CSR[VTYPE_ADDR] = _illmask | zimm;
                if(rd != 0) X[rd] = _vl;
                CSR[VSTART_ADDR] = 0;
            }
        }

        VSETIVLI {
            encoding: 1'b0 :: 1'b0 :: zimm[9:0] :: uimm[4:0] :: 3'b111 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(rd)}, {name(rs1)}, {zimm}";
            behavior: {
                unsigned<32> _vlmax = 0;
            }
        }
        VSETVL {
            encoding: 1'b1 :: 6'b000000 :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}";
            behavior: {

                unsigned<11> zimm[11] = X[rs2];
                unsigned<3> sew[3]  =  vtype_extractSEW(zimm);
                unsigned<3> lmul[3] =  vtype_extractLMUL(zimm);
                unsigned<1> vta[1]  =  vtype_extractTA(zimm);
                unsigned<1> vma[1]  =  vtype_extractMA(zimm);

                unsigned<XLEN> _vlmax = 0;
                unsigned<XLEN> _illmask = 0;

                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                if (lmul & 4){
                    _illmask = (1 << (XLEN-1));
                    if(lmul == 6){
                        _vlmax = _vlen / (0x8 << sew) / 4;
                    }else if(lmul == 7){
                        _vlmax = _vlen / (0x8 << sew) / 2;
                    }else{
                        _vlmax = _vlen / (0x8 << sew) / 8;
                    }
                }else {
                    _illmask = (0 << (XLEN-1));
                    if(lmul == 0){
                        _vlmax = _vlen / (0x8 << sew);
                    }else if(lmul == 1){
                        _vlmax = _vlen / (0x8 << sew) *2;
                    }else if(lmul == 2){
                        _vlmax = _vlen / (0x8 << sew) *4;
                    }else if(lmul == 3){
                        _vlmax = _vlen / (0x8 << sew) *8;
                    }
                }
                unsigned<32> _avl = 0;
                if (rs1 != 0){
                    _avl = X[rs1];
                }else if(rd != 0){
                    _avl = ~0;
                }else{
                    _avl = CSR[VL_ADDR];
                }

                unsigned<32> _vl = 0;

                if(_avl <= _vlmax){
                   _vl = _avl;
                }else if(_avl >= (2*_vlmax)){
                   _vl = _vlmax;
                }else{
                   _vl = (_avl % 0x2) ? _avl/2 +1 : _avl/2; // ceil (AVL/2)
                }

                CSR[VL_ADDR] = _vl;
                CSR[VTYPE_ADDR] = _illmask | zimm;
                if(rd != 0) X[rd] = _vl;
                CSR[VSTART_ADDR] = 0;
            }

        }
        // -- Vector Load and Store Instructions
        // vl[1,2,4,8]re[8,16,32,64].v?
        // vle[8,16,32,64].v?
        // vse[8,16,32,64].v?
        // vle[8,16,32,64]ff.v?
        // vlm.v?
        // vsm.v?
        // vloxei[8,16,32,64].v?
        // vsoxei[8,16,32,64].v?
        // vloxseg[?]ei[8,16,32,64].v?
        // vluxseg[?]ei[8,16,32,64].v?
        // vlse[8,16,32,64].v?
        // vsse[8,16,32,64].v?
        // vlseg[?]e[8,16,32,64].v?
        // vlsseg[?]e[8,16,32,64].v?
        // vsseg[?]e[8,16,32,64].v?
        // vluxei[8,16,32,64].v?
        // vsuxei[8,16,32,64].v?
        // vs[1,2,4,8]r.v?
        // This conflicts with the FLW/FSW encoding of the RV32F instruction set
        // VLE_U {
        //     encoding: 3'b000 :: mew[0:0] :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: width[2:0] :: vd[4:0] :: 7'b0000111;
        //     assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
        //     behavior: {

        //         unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
        //         unsigned<XLEN> _eew = vcfg_concatEEW(mew, width);
        //         unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
        //         unsigned<XLEN> _vl = CSR[VL_ADDR];
        //         unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

        //         unsigned<XLEN> ret = etiss_vload_encoded_unitstride(V, _vtype, vm, _eew, vd, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); // V, MEM[-1],
        //         if(ret != 0){
        //             CSR[VSTART_ADDR] = ret >> 8;
        //             raise(0, 2);
        //         } else{
        //             CSR[VSTART_ADDR] = 0;
        //         }
        //     }
        // }
        // Unitstride, 8 bit element
        VLE8_U {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _eew = vcfg_concatEEW(1'b0, 3'b000);
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = etiss_vload_encoded_unitstride(V, _vtype, vm, _eew, vd, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); // V, MEM[-1],
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Unitstride, 16 bit element
        VLE16_U {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _eew = vcfg_concatEEW(1'b0, 3'b101);
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = etiss_vload_encoded_unitstride(V, _vtype, vm, _eew, vd, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); // V, MEM[-1],
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Unitstride, 32 bit element
        VLE32_U {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _eew = vcfg_concatEEW(1'b0, 3'b110);
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = etiss_vload_encoded_unitstride(V, _vtype, vm, _eew, vd, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); // V, MEM[-1],
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Strided, 8 bit element
        VLE8_S {
            encoding: 3'b000 :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLE16_S {
            encoding: 3'b000 :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLE32_S {
            encoding: 3'b000 :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLE8FF_U {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b10000 :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLE16FF_U {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b10000 :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLE32FF_U {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b10000 :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLM_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b01011 :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        VLR_V {
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vs3)}, ({name(rs1)})";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLSEGE8 {
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLSEGE16 {
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLSEGE32 {
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        // This conflicts with the FLW/FSW encoding of the RV32F instruction set
        // VSE_U {
        //     encoding: 3'b000 :: mew[0:0] :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: width[2:0] :: vs3[4:0] :: 7'b0100111;
        //     assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
        //     behavior: {

        //         unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
        //         unsigned<XLEN> _eew = vcfg_concatEEW(mew, width);
        //         unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
        //         unsigned<XLEN> _vl = CSR[VL_ADDR];
        //         unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

        //         unsigned<XLEN> ret = etiss_vstore_encoded_unitstride(V, _vtype, vm, _eew, vs3, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); //V, MEM[-1],
        //         if(ret != 0){
        //             CSR[VSTART_ADDR] = ret >> 8;
        //             raise(0, 2);
        //         } else{
        //             CSR[VSTART_ADDR] = 0;
        //         }
        //     }
        // }
        // Unitstride, 8 bit element
        VSE8_U {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _eew = vcfg_concatEEW(1'b0, 3'b000);
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = etiss_vstore_encoded_unitstride(V, _vtype, vm, _eew, vs3, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); //V, MEM[-1],
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Unitstride, 16 bit element
        VSE16_U {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _eew = vcfg_concatEEW(1'b0, 3'b101);
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = etiss_vstore_encoded_unitstride(V, _vtype, vm, _eew, vs3, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); //V, MEM[-1],
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Unitstride, 32 bit element
        VSE32_U {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _eew = vcfg_concatEEW(1'b0, 3'b110);
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = etiss_vstore_encoded_unitstride(V, _vtype, vm, _eew, vs3, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); //V, MEM[-1],
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Strided, 8 bit element
        VSE8_S {
            encoding: 3'b000 :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSE16_S {
            encoding: 3'b000 :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSE32_S {
            encoding: 3'b000 :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSM_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b01011 :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSR_V {
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vs3)}, ({name(rs1)})";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        // -- Vector Integer Arithmetic Instructions
        // vadc.vim?
        // vadc.vvm?
        // vadc.vxm?
        // vdiv.vv?
        // vdiv.vx?
        // vdivu.vv?
        // vdivu.vx?
        // vmacc.vv?
        // vmacc.vx?
        // vmadc.vi?
        // vmadc.vim?
        // vmadc.vv?
        // vmadc.vvm?
        // vmadc.vx?
        // vmadc.vxm?
        // vmadd.vv?
        // vmadd.vx?
        // vmax.vv?
        // vmax.vx?
        // vmaxu.vv?
        // vmaxu.vx?
        // vmerge.vim?
        // vmerge.vvm?
        // vmerge.vxm?
        // vmin.vv?
        // vmin.vx?
        // vminu.vv?
        // vminu.vx?
        // vmsbc.vv?
        // vmsbc.vvm?
        // vmsbc.vxm?
        // vmsgtu.vi?
        // vmul.vv?
        // vmul.vx?
        // vmulh.vv?
        // vmulh.vx?
        // vmulhsu.vv?
        // vmulhsu.vx?
        // vmulhu.vv?
        // vmulhu.vx?
        // vnmsac.vv?
        // vnmsac.vx?
        // vnmsub.vv?
        // vnmsub.vx?
        // vnsra.wi?
        // vnsra.wv?
        // vnsra.wx?
        // vnsrl.wi?
        // vnsrl.wv?
        // vnsrl.wx?
        // vrem.vv?
        // vrem.vx?
        // vremu.vv?
        // vremu.vx?
        // vrsub.vi?
        // vrsub.vx?
        // vsbc.vvm?
        // vsbc.vxm?
        // vsext.vf2?
        // vsext.vf4?
        // vsext.vf8?
        // vwadd.wv?
        // vwadd.wx?
        // vwaddu.wv?
        // vwaddu.wx?
        // vwmacc.vv?
        // vwmaccsu.vv?
        // vwmaccsu.vx?
        // vwmaccu.vx?
        // vwmaccu.vv?
        // vwmacc.vx?
        VADD_VV {
            encoding: 6'b000000 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vadd_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VADD_VI {
            encoding: 6'b000000 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vadd_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VADD_VX {
            encoding: 6'b000000 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vadd_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSUB_VV {
            encoding: 6'b000010 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsub_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSUB_VX {
            encoding: 6'b000010 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

               unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
               unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
               unsigned<XLEN> _vl = CSR[VL_ADDR];
               unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

               unsigned<XLEN> ret = vsub_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
               if(ret != 0){
                   CSR[VSTART_ADDR] = ret >> 8;
                   raise(0, 2);
               } else{
                   CSR[VSTART_ADDR] = 0;
               }
           }
        }
        VWMUL_VV {
            encoding: 6'b111011 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        VWMUL_VX {
            encoding: 6'b111011 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VWADDU_VV {
            encoding: 6'b110000 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwaddu_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWADDU_VX {
            encoding: 6'b110000 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwaddu_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMUL_VV {
            encoding: 6'b100101 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VMUL_VX {
            encoding: 6'b100101 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        VWADD_VV {
            encoding: 6'b110001 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwadd_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWADD_VX {
            encoding: 6'b110001 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwadd_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWMACC_VV {
            encoding: 6'b111101 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        VWMACC_VX {
            encoding: 6'b111101 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        VWSUBU_VV {
            encoding: 6'b110010 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwsubu_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWSUBU_VX {
            encoding: 6'b110010 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwsubu_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWSUB_VV {
            encoding: 6'b110011 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwsub_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWSUB_VX {
            encoding: 6'b110011 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwsub_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWADDU_W_VV {
            encoding: 6'b110100 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwaddu_w_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWADDU_W_VX {
            encoding: 6'b110100 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwaddu_w_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWADD_W_VV {
            encoding: 6'b110101 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwadd_w_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWADD_W_VX {
            encoding: 6'b110101 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwadd_w_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWSUBU_W_VV {
            encoding: 6'b110110 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwsubu_w_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWSUBU_W_VX {
            encoding: 6'b110110 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwsubu_w_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWSUB_W_VV {
            encoding: 6'b110111 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwsub_w_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWSUB_W_VX {
            encoding: 6'b110111 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwsub_w_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VAND_VV {
            encoding: 6'b001001 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vand_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VAND_VI {
            encoding: 6'b001001 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vand_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VAND_VX {
            encoding: 6'b001001 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vand_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VOR_VV {
            encoding: 6'b001010 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vor_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VOR_VI {
            encoding: 6'b001010 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vor_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VOR_VX {
            encoding: 6'b001010 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vor_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VXOR_VV {
            encoding: 6'b001011 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vxor_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VXOR_VI {
            encoding: 6'b001011 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vxor_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VXOR_VX {
            encoding: 6'b001011 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vxor_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSLL_VV {
            encoding: 6'b100101 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsll_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSLL_VI {
            encoding: 6'b100101 :: vm[0:0] :: vs2[4:0] :: uimm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsll_vi(V, _vtype, vm, vd, vs2, uimm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSLL_VX {
            encoding: 6'b100101 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsll_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSRL_VV {
            encoding: 6'b101000 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsrl_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSRL_VI {
            encoding: 6'b101000 :: vm[0:0] :: vs2[4:0] :: uimm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsrl_vi(V, _vtype, vm, vd, vs2, uimm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSRL_VX {
            encoding: 6'b101000 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsrl_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSRA_VV {
            encoding: 6'b101001 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsra_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSRA_VI {
            encoding: 6'b101001 :: vm[0:0] :: vs2[4:0] :: uimm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsra_vi(V, _vtype, vm, vd, vs2, uimm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSRA_VX {
            encoding: 6'b101001 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsra_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSEQ_VV {
            encoding: 6'b011000 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmseq_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSSEQ_VI {
            encoding: 6'b011000 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(simm5)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmseq_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSEQ_VX {
            encoding: 6'b011000 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmseq_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSNE_VV {
            encoding: 6'b011001 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsne_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSNE_VI {
            encoding: 6'b011001 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(simm5)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsne_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSNE_VX {
            encoding: 6'b011001 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsne_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSLTU_VV {
            encoding: 6'b011010 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsltu_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSLTU_VX {
            encoding: 6'b011010 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsltu_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSLT_VV {
            encoding: 6'b011011 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmslt_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSLT_VX {
            encoding: 6'b011011 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmslt_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSLEU_VV {
            encoding: 6'b011100 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsleu_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSLEU_VI {
            encoding: 6'b011100 :: vm[0:0] :: vs2[4:0] :: uimm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(uimm5)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsleu_vi(V, _vtype, vm, vd, vs2, uimm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSLEU_VX {
            encoding: 6'b011100 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsleu_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSLE_VV {
            encoding: 6'b011101 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsle_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSLE_VI {
            encoding: 6'b011101 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(simm5)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsle_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSLE_VX {
            encoding: 6'b011101 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsle_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        // No need to implement pseudoinstructions?
        // VMSGTU_VV {
        //    encoding: 6'b011110 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
        //    assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
        //    behavior: {
        //
        //        unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
        //        unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
        //        unsigned<XLEN> _vl = CSR[VL_ADDR];
        //        unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;
        //
        //        unsigned<XLEN> ret = vmsgtu_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
        //        if(ret != 0){
        //            CSR[VSTART_ADDR] = ret >> 8;
        //            raise(0, 2);
        //        } else{
        //            CSR[VSTART_ADDR] = 0;
        //        }
        //    }
        // }

        VMSGTU_VX {
            encoding: 6'b011110 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsgtu_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMSGTU_VI {
            encoding: 6'b011110 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(simm5)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        // No need to implement pseudoinstructions?
        // VMSGT_VV {
        //     encoding: 6'b011111 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
        //     assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
        //     behavior: {
        //
        //         unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
        //         unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
        //         unsigned<XLEN> _vl = CSR[VL_ADDR];
        //         unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;
        //
        //         unsigned<XLEN> ret = vmsgt_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
        //         if(ret != 0){
        //             CSR[VSTART_ADDR] = ret >> 8;
        //             raise(0, 2);
        //         } else{
        //             CSR[VSTART_ADDR] = 0;
        //         }
        //     }
        // }

        VMSGT_VX {
            encoding: 6'b011111 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsgt_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMV_V_X {
            encoding: 6'b010111 :: 1'b1 :: 5'b00000 :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmv_vx(V, X, _vtype, vd, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMV_V_V {
          encoding: 6'b010111 :: 1'b1 :: 5'b00000 :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs1)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmv_vv(V, _vtype, vd, vs1, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMV_V_I {
            encoding: 6'b010111 :: 1'b1 :: 5'b00000 :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(simm5)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmv_vi(V, _vtype, vd, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VZEXT {
            encoding: 6'b010010 :: 1'b1 :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(rd)}, {name(vs2)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }


        // -- Vector Fixed-point Arithmetic Instructions
        // vaadd.vv?
        // vaadd.vx?
        // vaaddu.vv?
        // vaaddu.vx?
        // vasub.vv?
        // vasub.vx?
        // vasubu.vv?
        // vasubu.vx?
        // vnclip.wi?
        // vnclip.wv?
        // vnclip.wx?
        // vnclipu.wi?
        // vnclipu.wv?
        // vnclipu.wx?
        // vsadd.vi?
        // vsadd.vv?
        // vsadd.vx?
        // vsaddu.vi?
        // vsaddu.vv?
        // vsaddu.vx?
        // vsmul.vv?
        // vsmul.vx?
        // vssra.vi?
        // vssra.vv?
        // vssra.vx?
        // vssrl.vi?
        // vssrl.vv?
        // vssrl.vx?
        // vssub.vv?
        // vssub.vx?
        // vssubu.vv?
        // vssubu.vx?
        // -- Vector Single-Width Integer Reduction Instructions
        // vredand.vs?
        // vredmax.vs?
        // vredmaxu.vs?
        // vredmin.vs?
        // vredminu.vs?
        // vredor.vs?
        // vredxor.vs?
        VREDSUM_VS {
            encoding: 6'b000000 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        // -- Vector Widening Integer Reduction Instructions
        // vwredsum.vs?
        // vwredsumu.vs?
        // -- Vector Mask Instructions
        // vcpop.m?
        // vfirst.m?
        // viota.m?
        // vmand.mm?
        // vmandn.mm?
        // vmclr.m?
        // vmmv.m?
        // vmnand.mm?
        // vmnor.mm?
        // vmnot.m?
        // vmor.mm?
        // vmorn.mm?
        // vmset.m?
        // vmsif.m?
        // vmsof.m?
        // vmxnor.mm?
        // vmxor.mm?
        VID_V {
            encoding: 6'b010100 :: 1'b1 :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(rd)}, {name(vs2)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        // -- Vector Permutation Instructions
        // vmcompress.vm?
        // vfmv.f.s?
        // vfmv.s.f?
        // vmv.x.s?
        // vrgatherei16.vv?
        VMVR_V {
            encoding: 6'b100111 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VRGATHER_VV {
            encoding: 6'b001100 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        VRGATHER_VI {
            encoding: 6'b001100 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        VRGATHER_VX {
            encoding: 6'b001100 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VMV_X_S {
            encoding: 6'b010000 :: 1'b1 :: vs2[4:0] :: 5'b00000 :: 3'b010 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(rd)}, {name(vs2)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                //unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                if(rd != 0){
                    unsigned<XLEN> ret = vmv_xs(V, X, _vtype, rd, vs2, _vlen, _vl, XLEN);
                    if(ret != 0){
                        CSR[VSTART_ADDR] = ret >> 8;
                        raise(0, 2);
                    } else{
                        CSR[VSTART_ADDR] = 0;
                    }
                }
            }
        }
        VMV_S_X {
            encoding: 6'b010000 :: 1'b1 :: 5'b00000 :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmv_sx(V, X, _vtype, vd, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VSLIDEUP_VI {
            encoding: 6'b001110 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(simm5)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vslideup_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSLIDEUP_VX {
            encoding: 6'b001110 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vslideup_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        // TODO: vfslide1up vrgatherei16

        VSLIDEDOWN_VI {
            encoding: 6'b001111 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(simm5)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vslidedown_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSLIDEDOWN_VX {
            encoding: 6'b001111 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vslidedown_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSLIDE1UP_VX {
            encoding: 6'b001110 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vslide1up_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSLIDE1DOWN_VX {
            encoding: 6'b001111 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vslide1down_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // -- 2 Sort






        // TODO: vmv.f.s vmv.s.f (requires floating point registers)


    }

}


InstructionSet RVVBase extends Zicsr {

    architectural_state {
        unsigned<32> VLEN = 1024;
        // user-writeable
        unsigned<32> VSTART_ADDR = 0x008;
        unsigned<32>& VSTART_CSR = CSR[VSTART_ADDR];
        unsigned<32> VXSAT_ADDR = 0x009;
        unsigned<32>& VXSAT_CSR = CSR[VXSAT_ADDR];
        unsigned<32> VXRM_ADDR = 0x00A;
        unsigned<32>& VXRM_CSR = CSR[VXRM_ADDR];
        unsigned<32> VCSR_ADDR = 0x00F;
        unsigned<32>& VCSR_CSR = CSR[VCSR_ADDR];

        // not user-writable
        unsigned<32> VL_ADDR = 0xC20;
        unsigned<32>& VL_CSR = CSR[VL_ADDR];
        unsigned<32> VTYPE_ADDR = 0xC21;
        unsigned<32>& VTYPE_CSR = CSR[VTYPE_ADDR];

        // read-only constant csr
        unsigned<32> VLENB_ADDR = 0xC22;
        unsigned<32>& VLENB_CSR = CSR[VLENB_ADDR];

        // vector register address space
        extern unsigned char V[VLEN * 32];
    }
    functions {
        extern unsigned<8> vtype_extractSEW(unsigned<16>);
        extern unsigned<8> vtype_extractLMUL(unsigned<16>);
        extern unsigned<8> vtype_extractTA(unsigned<16>);
        extern unsigned<8> vtype_extractMA(unsigned<16>);
        extern unsigned<16> vcfg_concatEEW(unsigned<8> mew, unsigned<8> width);
        // bool check_eew() {
        //     return true;
        // }
    }
}
