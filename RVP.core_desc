import "RISCVBase.core_desc"

InstructionSet RV32P extends RISCVBase {

	  instructions {
      	// This instruction adds the 8-bit integer elements in Rs1 with the 8-bit integer elements in Rs2,
      	// and then writes the 8-bit element results to Rd.
      	// Rd.B[x] = Rs1.B[x] + Rs2.B[x];
      	ADD8 {
						encoding: 0b0100100 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
            args_disass:"{name(rs2)}, {name(rs1)}, {name(rd)}";
            behavior: {
                if(rd != 0) {
            	      unsigned<32> rs1_val = X[rs1];
            	      unsigned<32> rs2_val = X[rs2];
                    unsigned<8> rd_val0 = rs1_val[7:0] + rs2_val[7:0];
                    unsigned<8> rd_val1 = rs1_val[15:8] + rs2_val[15:8];
                    unsigned<8> rd_val2 = rs1_val[23:16] + rs2_val[23:16];
                    unsigned<8> rd_val3 = rs1_val[31:24] + rs2_val[31:24];
            	      unsigned<32> rd_val = rd_val3 :: rd_val2 :: rd_val1 :: rd_val0;
            	      X[rd] = rd_val;
                }
            }
      	}
      	// This instruction adds the 16-bit integer elements in Rs1 with the 16-bit integer elements in Rs2,
      	// and then writes the 16-bit element results to Rd.
      	// Rd.H[x] = Rs1.H[x] + Rs2.H[x];
      	ADD16 {
      		  encoding: 0b0100000 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
            args_disass:"{name(rs2)}, {name(rs1)}, {name(rd)}";
            behavior: {
                if(rd != 0) {
            	      unsigned<32> rs1_val = X[rs1];
            	      unsigned<32> rs2_val = X[rs2];
                    unsigned<16> rd_val0 = rs1_val[15:0] + rs2_val[15:0];
                    unsigned<16> rd_val1 = rs1_val[31:16] + rs2_val[31:16];
            	      unsigned<32> rd_val = rd_val1 :: rd_val0;
            	      X[rd] = rd_val;
                }
            }
      	}
      	// This instruction subtracts the 8-bit integer elements in Rs2 from the 8-bit integer elements in Rs1,
      	// and then writes the result to Rd.
      	// Rd.B[x] = Rs1.B[x] - Rs2.B[x];
      	SUB8 {
      		  encoding: 0b0100101 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
            args_disass:"{name(rs2)}, {name(rs1)}, {name(rd)}";
            behavior: {
                if(rd != 0) {
                 	  unsigned<32> rs1_val = X[rs1];
                	  unsigned<32> rs2_val = X[rs2];
                    signed<8> rd_val0 = (signed<8>)rs1_val[7:0] - (signed<8>)rs2_val[7:0];
                    signed<8> rd_val1 = (signed<8>)rs1_val[15:8] - (signed<8>)rs2_val[15:8];
                    signed<8> rd_val2 = (signed<8>)rs1_val[23:16] - (signed<8>)rs2_val[23:16];
                    signed<8> rd_val3 = (signed<8>)rs1_val[31:24] - (signed<8>)rs2_val[31:24];
                	  X[rd] = rd_val3 :: rd_val2 :: rd_val1 :: rd_val0;
                }
              }
      	}
      	// This instruction multiplies the four signed 8-bit elements of 32-bit chunks of Rs1
      	// with the four signed 8-bit elements of 32-bit chunks of Rs2 and then adds the four results together
      	// with the signed content of the corresponding 32-bit chunks of Rd.
      	// The final results are written back to the corresponding 32-bit chunks in Rd.
      	// res[x] = Rd.W[x] + (Rs1.W[x].B[3] s* Rs2.W[x].B[3]) + (Rs1.W[x].B[2] s* Rs2.W[x].B[2])
      	//			+ (Rs1.W[x].B[1] s* Rs2.W[x].B[1]) + (Rs1.W[x].B[0] s* Rs2.W[x].B[0]);
	     	// Rd.W[x] = res[x];
      	SMAQA {
        		encoding: 0b1100100 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
            args_disass:"{name(rs2)}, {name(rs1)}, {name(rd)}";
            behavior: {
                if(rd != 0) {
                	  unsigned<32> rs1_val = X[rs1];
                	  unsigned<32> rs2_val = X[rs2];
                	  signed<32> rd_val = X[rd];
                    signed<32> tmp_val0 = (signed<8>)rs1_val[7:0] * (signed<8>)rs2_val[7:0] + (signed<8>)rd_val[7:0];
                    signed<32> tmp_val1 = (signed<8>)rs1_val[15:8] * (signed<8>)rs2_val[15:8] + (signed<8>)rd_val[15:8];
                    signed<32> tmp_val2 = (signed<8>)rs1_val[23:16] * (signed<8>)rs2_val[23:16] + (signed<8>)rd_val[23:16];
                    signed<32> tmp_val3 = (signed<8>)rs1_val[31:24] * (signed<8>)rs2_val[31:24] + (signed<8>)rd_val[31:24];
                    rd_val = rd_val + tmp_val3 + tmp_val2 + tmp_val1 + tmp_val0;
                  	X[rd] = rd_val;
                }
            }
      	}
      	// The 8-bit elements in Rs1 are left-shifted logically. And the results are written to Rd.
      	// The shifted out bits are filled with zero and the shift amount is specified by the low-order 3-bits of the value in the Rs2 register.
	  	// Rd.B[x] = Rs1.B[x] << Rs2[2:0];
      	SLL8 {
      		  encoding: 0b0101110 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
            args_disass:"{name(rs2)}, {name(rs1)}, {name(rd)}";
            behavior: {
                if(rd != 0) {
            	      unsigned<32> rs1_val = X[rs1];
            	      unsigned<32> rs2_val = X[rs2];
                    unsigned<8> rd_val0 = rs1_val[7:0] << rs2_val[2:0];
                    unsigned<8> rd_val1 = rs1_val[15:8] << rs2_val[10:8];
                    unsigned<8> rd_val2 = rs1_val[23:16] << rs2_val[18:16];
                    unsigned<8> rd_val3 = rs1_val[31:24] << rs2_val[26:24];
            	      unsigned<32> rd_val = rd_val3 :: rd_val2 :: rd_val1 :: rd_val0;
            	      X[rd] = rd_val;
                }
            }
      	}
      	// This instruction compares the 8-bit signed integer elements in Rs1 with the 8-bit signed integer elements in Rs2
      	// and selects the numbers that is less than the other one. The selected results are written to Rd.
      	// Rd.B[x] = (Rs1.B[x] < Rs2.B[x]) ? Rs1.B[x] : Rs2.B[x];
      	SMIN8 {
      	  	encoding: 0b1000100 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
            args_disass:"{name(rs2)}, {name(rs1)}, {name(rd)}";
            behavior: {
                if(rd != 0) {
            	      unsigned<32> rs1_val = X[rs1];
            	      unsigned<32> rs2_val = X[rs2];
                    unsigned<8> rd_val0 = rs1_val[7:0] < rs2_val[7:0] ? rs1_val[7:0] : rs2_val[7:0];
                    unsigned<8> rd_val1 = rs1_val[15:8] < rs2_val[15:8] ? rs1_val[15:8] : rs2_val[15:8];
                    unsigned<8> rd_val2 = rs1_val[23:16] < rs2_val[23:16] ? rs1_val[23:16] : rs2_val[23:16];
                    unsigned<8> rd_val3 = rs1_val[31:24] < rs2_val[31:24] ? rs1_val[31:24] : rs2_val[31:24];
            	      unsigned<32> rd_val = rd_val3 :: rd_val2 :: rd_val1 :: rd_val0;
            	      X[rd] = rd_val;
                }
            }
      	}
      	// This instruction compares the 8-bit signed integer elements in Rs1 with the 8-bit signed integer elements in Rs2
      	// and selects the numbers that is greater than the other one. The selected results are written to Rd.
      	// Rd.B[x] = (Rs1.B[x] > Rs2.B[x]) ? Rs1.B[x] : Rs2.B[x];
      	SMAX8 {
      	  	encoding: 0b1000101 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
            args_disass:"{name(rs2)}, {name(rs1)}, {name(rd)}";
            behavior: {
                if(rd != 0) {
            	      unsigned<32> rs1_val = X[rs1];
            	      unsigned<32> rs2_val = X[rs2];
                    unsigned<8> rd_val0 = rs1_val[7:0] > rs2_val[7:0] ? rs1_val[7:0] : rs2_val[7:0];
                    unsigned<8> rd_val1 = rs1_val[15:8] > rs2_val[15:8] ? rs1_val[15:8] : rs2_val[15:8];
                    unsigned<8> rd_val2 = rs1_val[23:16] > rs2_val[23:16] ? rs1_val[23:16] : rs2_val[23:16];
                    unsigned<8> rd_val3 = rs1_val[31:24] > rs2_val[31:24] ? rs1_val[31:24] : rs2_val[31:24];
            	      unsigned<32> rd_val = rd_val3 :: rd_val2 :: rd_val1 :: rd_val0;
            	      X[rd] = rd_val;
                }
            }
      	}
      	// This instruction compares the 16-bit signed integer elements in Rs1 with the 16-bit signed integer elements in Rs2
      	// and selects the numbers that is greater than the other one. The selected results are written to Rd.
      	// Rd.H[x] = (Rs1.H[x] > Rs2.H[x]) ? Rs1.H[x] : Rs2.H[x];
      	SMAX16 {
      	  	encoding: 0b1000001 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
            args_disass:"{name(rs2)}, {name(rs1)}, {name(rd)}";
            behavior: {
                if(rd != 0) {
            	      unsigned<32> rs1_val = X[rs1];
            	      unsigned<32> rs2_val = X[rs2];
                    unsigned<16> rd_val0 = rs1_val[15:0] > rs2_val[15:0] ? rs1_val[7:0] : rs2_val[15:0];
                    unsigned<16> rd_val1 = rs1_val[31:16] > rs2_val[31:16] ? rs1_val[31:16] : rs2_val[31:16];
            	      unsigned<32> rd_val = rd_val1 :: rd_val0;
            	      X[rd] = rd_val;
                }
            }
      	}
      	// This instruction compares the 8-bit signed integer elements in Rs1 with the 8-bit signed integer elements in Rs2
      	// to see if the one in Rs1 is less than or equal to the one in Rs2.
      	// If it is true, the result is 0xFF; otherwise, the result is 0x0. The element comparison results are written to Rd
      	// Rd.B[x] = (Rs1.B[x] <= Rs2.B[x]) ? 0xff : 0x0;
      	SCMPLE8 {
      		  encoding: 0b0001111 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
            args_disass:"{name(rs2)}, {name(rs1)}, {name(rd)}";
            behavior: {
                if(rd != 0) {
            	      unsigned<32> rs1_val = X[rs1];
            	      unsigned<32> rs2_val = X[rs2];
                    unsigned<8> rd_val0 = rs1_val[7:0] <= rs2_val[7:0] ? 0xff : 0x00;
                    unsigned<8> rd_val1 = rs1_val[15:8] <= rs2_val[15:8] ? 0xff : 0x00;
                    unsigned<8> rd_val2 = rs1_val[23:16] <= rs2_val[23:16] ? 0xff : 0x00;
                    unsigned<8> rd_val3 = rs1_val[31:24] <= rs2_val[31:24] ? 0xff : 0x00;
            	      unsigned<32> rd_val = rd_val3 :: rd_val2 :: rd_val1 :: rd_val0;
            	      X[rd] = rd_val;
                }
            }
      	}
        // TODO
        // Mresult = ZE33(Rs1) u* ZE33(Rs2);
        // R[Rd(4,1).1(0)][31:0] = Mresult[63:32];
        // R[Rd(4,1).0(0)][31:0] = Mresult[31:0];
      	MULR64 {
        		encoding: 0b1111000 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
            args_disass:"{name(rs2)}, {name(rs1)}, {name(rd)}";
            behavior: {
             	  unsigned<32> rs1_val = X[rs1];
             	  unsigned<32> rs2_val = X[rs2];
            	  unsigned<64> product = rs1_val * rs2_val;
              	X[rd[4:1]*2+1] = product[63:32];
              	X[rd[4:1]*2] = product[31:0];
            }
      	}
        // TODO
      	ADD64 {
        		encoding: 0b1100000 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
            args_disass:"{name(rs2)}, {name(rs1)}, {name(rd)}";
            behavior: {
             	  signed<64> rs1_val = X[rs1[4:1]*2+1] :: X[rs1[4:1]*2];
             	  signed<64> rs2_val = X[rs2[4:1]*2+1] :: X[rs2[4:1]*2];
            	  signed<64> sum = rs1_val + rs2_val;
              	X[rd[4:1]*2+1] = sum[63:32];
              	X[rd[4:1]*2] = sum[31:0];
            }
      	}
      	MIN {
      	  	encoding: 0b0000101 :: rs2[4:0] :: rs1[4:0] :: 0b100 :: rd[4:0] :: 0b0110011;
            args_disass:"{name(rs2)}, {name(rs1)}, {name(rd)}";
            behavior: {
                if(rd != 0) {
            	      signed<32> rs1_val = X[rs1];
            	      signed<32> rs2_val = X[rs2];
                    signed<32> rd_val = rs1_val < rs2_val ? rs1_val : rs2_val;
            	      X[rd] = rd_val;
                }
            }
      	}
      	MAX {
      	  	encoding: 0b0000101 :: rs2[4:0] :: rs1[4:0] :: 0b110 :: rd[4:0] :: 0b0110011;
            args_disass:"{name(rs2)}, {name(rs1)}, {name(rd)}";
            behavior: {
                if(rd != 0) {
            	      signed<32> rs1_val = X[rs1];
            	      signed<32> rs2_val = X[rs2];
                    signed<32> rd_val = rs1_val >= rs2_val ? rs1_val : rs2_val;
            	      X[rd] = rd_val;
                }
            }
      	}
	  }
}
